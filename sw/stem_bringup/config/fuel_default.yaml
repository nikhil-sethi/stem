define: &max_vel 0.4
define: &max_acc 0.25

sdf_map:
  resolution: 0.1
  map_size_x: 12 # 11
  map_size_y: 12 # 11
  map_size_z: 1.5
  obstacles_inflation: 0.199
  local_bound_inflate: 0.5
  local_map_margin: 50
  ground_height: -0.2
  default_dist: 0.0
  p_hit: 0.68
  p_miss: 0.48  # 0.47 works best in sim. Higher values we are more liberal, so there are more false positives as well
  p_min: 0.12
  p_max: 0.99
  p_occ: 0.7 # keep this lower if there is a lot of noise. But higher values also might lead to more false positives
  min_ray_length: 0.5
  max_ray_length: 3
  virtual_ceil_height: -10
  optimistic: false
  signed_dist: false
  box_min_x: -6 #-5.5
  box_min_y: -6 #-5.5
  box_max_x:  6 #5.5
  box_max_y:  6 #5.5
  box_min_z:  -0.0
  box_max_z: 1.5

map_ros:         # Gazebo        # Intel realsense 4255  
  cx: 422.86578  # 424.50000     # 422.86578  
  cy: 242.46154  # 240.50000     # 242.46154
  fx: 427.75729  # 454.68577     # 427.75729
  fy: 427.75729  # 454.68577     # 427.75729
  depth_filter_maxdist: 3
  depth_filter_mindist: 0.2
  depth_filter_margin: 2
  k_depth_scaling_factor: 1000.0  # the realsense gives values in mm, so keep it to 1000 for real world testing
  skip_pixel: 4  # how many pixels to to skip consecutively while going over the depth image to create the cloud
  esdf_slice_height: 0.1
  visualization_truncate_height: 10.09
  visualization_truncate_low: -2.0
  show_occ_time: false
  show_esdf_time: false
  show_all_map: true
  frame_id: world

fsm:
  # Replan if the time left to complete the current trajectory is below this
  # lower values mean you're confident about your paths and plan less frequently but might be jerky if the next plan is very differnt from the current
  # higher values help replan before and be stable to sudden changes, but also means you change the plan more frequently
  thresh_replan1: 0.5  # [s]
  
  # Replan if you have executed at least this amount of trajectory AND the next frontier is covered.
  # This helps the drone to execute at least something before replanning because we need to keep it moving
  thresh_replan2: 0.3 # [s]

  # In any case, always replan after this much real time has elapsed. Helps the drone get out stuck places and keeps it going
  # This can be higher if your drone moves slower because you dont want to keep replanning always
  thresh_replan3: 1.5 # [s]
  replan_time: 0.2

exploration:
  refine_local: true
  refined_num: 7

  # the radius in which you refine viewpoints using Dijkstra
  refined_radius: 3.0
  max_decay: 0.8
  top_view_num: 15
  vm: *max_vel
  am: *max_acc
  
  # Cost to change yaw angle 
  # this should ideally be matched closely with the controller's maximum yaw rate, but might need to be more conservative because of noise and delays
  # with the real drone, it seems we need to be much more conservative than the control limit
  # this is also linked to the free space the trajectory has for moving around (dist0 param in optimization)
  yd:  0.7     # "$(eval 25 * 3.1415926 / 180.0)"  

  # NOT USED
  ydd: 1.5707963     # "$(eval 90 * 3.1415926 / 180.0)"
  
  # Cost to change velocity vector direction
  # higher values resist changes and act more sluggish but result in better, stable movements
  # lower values decrease flight times but with poor mapping
  w_dir: 1.5
  tsp_dir: "/workspaces/stem_ws/src/thesis/sw/planning/FUEL/fuel_planner/utils/lkh_tsp_solver/resource/" # YAML limitation: needs to be remapped from outside if you want relative paths. 
  relax_time: 1.0

frontier:
  cluster_min: 0 # used to discard frontiers smaller than this value
  cluster_size_xy: 1.5 # used by PCA to split large frontiers 
  cluster_size_z: 10
  
  # minimum distance a viewpoint needs to be from the centroid of a frontier to be considered
  # If higher than rmin, it will discard some bad viewpoints
  min_candidate_dist: 0.5  
  
  # how far must a viewpoint candidate be from unknown space to be considered. Like a safety margin.
  # high values can sometimes mean that there is no vpt available and 'search fails'
  min_candidate_clearance: 0.21

  # Angle delta for viewpoint sampling
  # if you have very small narrow spaces, keep this lower, but doesnt affect too much tbh
  candidate_dphi: 0.261  # "$(eval 15 * 3.1415926 / 180.0)"
  
  # how many concentric circles of viewpoints to sample between rmin and rmax 
  candidate_rnum: 3
  # lower radius of viewpoint sampling around a frontier
  candidate_rmin: 0.75 # [m]
  # max radius for viewpoint sampling around a frontier
  candidate_rmax: 1.75 # [m]
  down_sample: 3

  # how many valid frontier voxels does a viewpoint need to see to be considered
  # lower values mean we have a lot of viewpoints even in small places
  # higher values means we are conservative about what a viewpoint sees
  # also depends a lot on your map resolution
  min_visib_num: 20
  
  # % change that must happen for the frontier to call for recompute
  # Low values mean that we moved along very fast across the space, considering even a small changed to be enough to reevaluate
  # high values mean we are more strict. We make a lot of observations before moving. This is sluggish but makes the environment scene more stable
  # it should be tuned such that your observe smooth motions, without stops or fast acclerations
  min_view_finish_fraction: 0.1

perception_utils:
  top_angle: 0.51129 # np.arctan2(H/2, fx)
  left_angle: 0.7809 # np.arctan2(W/2, fx)
  right_angle: 0.7809 # np.arctan2(W/2, fx)
  max_dist: 3
  vis_dist: 1.0


# UNUSED
# heading_planner:
#   yaw_diff: 0.523598767 # "$(eval 30 * 3.1415926 / 180.0)"
#   half_vert_num: 5
#   lambda1: 2.0
#   lambda2: 1.0
#   max_yaw_rate: 0.174532922 # "$(eval 10 * 3.1415926 / 180.0)"
#   w: 20000.0
#   weight_type: 1

manager:
  max_vel: *max_vel
  max_acc: *max_acc
  max_jerk: 2
  dynamic_environment: 0
  local_segment_length: 6.0
  clearance_threshold: 0.2
  control_points_distance: 0.35
  use_geometric_path: true
  use_kinodynamic_path: true
  use_topo_path: true
  use_optimization: true
  min_time: true

  # helps discard yaw angle plans that have large changes
  max_yawdot: 0.45  # 60 * 3,1415926 / 180,0
  relax_time1: 0.3  # not used
  relax_time2: 1.5

search:

  # max time to sample for the motion primitive. Increase this if you see a lot of searched being failed and paths getting cut
  # when the drone is moving slower, usually a higher value is required to find longer horizon paths. 
  max_tau: 2

  init_max_tau: 2
  max_vel: *max_vel
  vel_margin: 0.25
  max_acc: *max_acc
  w_time: 10.0
  horizon: 6.0
  lambda_heu: 10.0
  resolution_astar: 0.025
  time_resolution: 0.8
  margin: 0.2
  allocate_num: 100000
  check_num: 10
  optimistic: false

astar:
  lambda_heu: 10000.0
  resolution_astar: 0.2
  allocate_num: 1000000
  max_search_time: 0.001

optimization:
  ld_smooth: 20.0

  # cost to keep dist0 distance from the ESDF
  ld_dist: 10.0
  ld_feasi: 10.0 # how much to respect max vel and max acc
  ld_start: 100.0

  # cost to arrive at the last pose
  # keep it higher if you want it to be strict. But it can also make the trajectory infeasible sometimes
  ld_end: 0.5
  ld_guide: 1.5
  ld_waypt: 0.3
  ld_view: 0.0
  ld_time: 1.0

  # The minimum distance the trajectory should maintain from obstacles
  # in practice this should be higher than what you expect because of noise etc.
  # But this distance is also valid from the ground (in z axis), so if the drone wants to see something close to the ground, it will find it hard to do and keep oscillating
  dist0: 0.5 # [m]
  max_vel: *max_vel
  max_acc: *max_acc
  algorithm1: 15
  algorithm2: 11
  max_iteration_num1: 2
  max_iteration_num2: 2000
  max_iteration_num3: 200
  max_iteration_num4: 200
  max_iteration_time1: 0.0001
  max_iteration_time2: 0.005
  max_iteration_time3: 0.003
  max_iteration_time4: 0.003
  bspline:
    limit_vel: *max_vel
    limit_acc: *max_acc
    limit_ratio: 1.1
